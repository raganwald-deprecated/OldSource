/** * * DilutedInterpreter.java * * DilutedInterpreters handle escape procedures but * not continuations.**/package codestorm.scheme;import java.util.*;import codestorm.scheme.primitives.Not;import codestorm.scheme.primitives.GetInversion;public final class DilutedInterpreter {private static DilutedInterpreter _instance = new DilutedInterpreter();public static DilutedInterpreter instance () {	return _instance;}private static AbEnvironment _global;private java.util.Hashtable escapeSet = new Hashtable();private static boolean debugFlag = false;private static boolean traceFlag = false;public DilutedInterpreter () {}private static AbEnvironment global () {	if ( _global == null )		_global = GlobalEnvironment.instance();	return _global;}public static void setDebugFlag (boolean flag) {	debugFlag = flag;	traceFlag = debugFlag && traceFlag;}public static void setTraceFlag (boolean flag) {	traceFlag = flag;	debugFlag = debugFlag || traceFlag;}public static boolean getDebugFlag () {	return debugFlag;}public static boolean getTraceFlag () {	return traceFlag;}public AbEntity eval (AbEntity e) throws Exception {	return eval(e,global());}public AbEntity evalWithMeaning (AbEntity e) throws Exception {	AbEntity treatedExpr = meaning(e,global(),Nil.instance());	return eval(treatedExpr,global());}public AbEntity evalWithMeaning (AbEntity e, AbEnvironment r) throws Exception {	AbEntity treatedExpr = meaning(e,r,Nil.instance());	return eval(treatedExpr,r);}public AbEntity eval (AbEntity e, AbEnvironment r) throws Exception {	AbEntity exp = e;	AbEntity startExp = exp;	AbEnvironment env = r;	boolean isTail;	String expInStr = "";	String expOutStr = "";		do {			if ( debugFlag)			expInStr = exp.pp();			isTail = false;				if ( exp.isExpandable() ) {			env = ((Expandable) exp).getEnvironment();			exp = ((Expandable) exp).getExpression();			isTail = true;		}		else if ( exp.isaSymbol() ) {			try {				AbEntity val = env.lookup((Symbol) exp);				if ( val == null )					throw new Exception(exp.pp() + " is not defined in " + (debugFlag ? env.pp() : "the current environment"));				else exp = val;			}			catch (Exception ex) {				throw new Exception("Unable to look up "+exp.pp()+" in " + (debugFlag ? env.pp() : "the current environment")+" because "+ex.getMessage());			}		}		else if ( exp.isaThunk() ) {			try {				exp = ((AbThunk) exp).lookup(env);			}			catch (Exception ex) {				throw new Exception("Unable to look up "+exp.pp()+" in "+(debugFlag ? env.pp() : "the current environment")+" because "+ex.getMessage());			}		}		else if ( exp.isanAtom() )			;		else if ( exp.isaPair() ) { // list, APPLY			AbEntity head = exp.car();						if ( head == Symbol._quote_ )				exp = exp.cdr().car(); // NO evaluation (it's a QUOTE!)			else if ( head == Symbol._if_ ) {				// first expression is not in tail position				// empty list counts as true!				if ( eval(exp.cdr().car(),env).isFalseValue() )					exp = (exp.cdr().cdr().cdr().car()); // false				else exp = (exp.cdr().cdr().car()); // true				isTail = true;			}			else if ( head == Symbol._define_ ) {				AbEntity target = exp.cdr().car();				if ( target.isaSymbol() ) { // (define expInStr ...)					if ( exp.cdr().cdr().isaPair() ) // supplied with a value						exp = env.define(target,eval(exp.cdr().cdr().car(),env));					else exp = env.define(target,Uninitialized.instance());				}				// (define (expInStr x) ...)				// more than just syntactic sugar! this allows a future preprocessor				// to perform such tricks as checking arity and substituting inline				// code. The lambda style notation (define expInStr (lambda (x) ...))				// leaves the compiler confused as to how to handle (expInStr ...).				else if ( target.isaPair() ) {					AbEntity sym = target.car();					if ( !sym.isaSymbol() )						throw new Exception( "Attempt to define "+sym.pp() + " as a function");					else if ( exp.cdr().cdr().isaPair() ) { // supplied with a value						AbEntity bodyExpr = Pair.cons(Symbol._begin_,exp.cdr().cdr());						AbEntity lambda = new Closure(target.cdr(),bodyExpr,env);						exp = env.define((Symbol) sym,lambda);					}					else throw new Exception( exp.pp() + " is illegal because defined functions must include a body");				}				else throw new Exception( target.pp() + " must be a symbol or list in define");			}			else if ( head == Symbol._setBang_ ) {				AbEntity sym = exp.cdr().car();				if ( sym.isaSymbol() ) {					AbEnvironment home = env.locate(sym);					if ( home == null )						throw new Exception(exp.pp() + " is not defined in " + (debugFlag ? env.pp() : "the current environment") );					if ( exp.cdr().cdr().isaPair() ) // supplied with a value						exp = env.bind(sym,eval(exp.cdr().cdr().car(),env));					else throw new Exception("Must bind a value to " + sym.pp() );				}				else if ( sym.isaThunk() )					try {						exp = ((AbThunk) sym).bind(env,eval(exp.cdr().cdr().car(),env));					}					catch (Exception eSetBang) {						System.err.println(eSetBang+": "+eSetBang.getMessage()+" in "+exp);						throw eSetBang;					}				else throw new Exception( sym.pp() + " must be a Symbol or AbThunk in "+exp.pp() );			}			else if ( head == Symbol._setStarBang_ ) {				AbEntity sym = exp.cdr().car();				if ( sym.isaThunk() )					exp = ((AbThunk) sym).bindValues(env,(AbOrderedCollection) eval(exp.cdr().cdr().car(),env));				else throw new Exception( sym.pp() + " can only be a thunk in "+exp.pp() );			}			else if ( head == Symbol._lambda_ )				if ( exp.cdr().car().isaClosure() ) // template supplied					exp = ((Closure) exp.cdr().car()).copyIfInUse(env);				else exp = new Closure(exp.cdr().car(), exp.cdr().cdr().car(), env);			else if ( head == Symbol._macro_ ) {				Closure lambda = new Closure(exp.cdr().car(), Pair.cons(Symbol._begin_,exp.cdr().cdr()), env);				lambda.setSpecial(true);				exp = lambda; // value			}			else if ( head == Symbol._begin_ ) {				AbEntity expList = exp.cdr();				if ( expList.isNIL() )					throw new Exception("Incorrect arity for begin");				exp = expList.car();				expList = expList.cdr();				while ( !expList.isNIL() ){					eval(exp,env); // for side effects					exp = expList.car();					expList = expList.cdr();				}				isTail = true; // last expression is in tail position			}			else if ( head == Symbol._tail_apply_ ) {				AbEntity lambda = exp.cdr().car();								if ( !lambda.isaFunction() )					lambda = eval(lambda, env); // not in tail position--but do we HAVE to? Let's try saving time...								exp = exp.cdr().cdr();									if ( ((Closure) lambda).getSuperClosure() ) {					codestorm.util.CodableVector parVect = new codestorm.util.CodableVector(16,8); // initial capacity, capacity increment					while ( exp.isaPair() ) {						parVect.addElement(eval(exp.car(),env));						exp = exp.cdr();					}					env = ((Closure) lambda).invocationEnv(parVect); // sorry, not constant space				}				else {					int i = 0;					while ( exp.isaPair() ) {						env.bind(i++,eval(exp.car(),env));						exp = exp.cdr();					}				}				exp = ((Closure) lambda).getExpression();				isTail = true;			}			else if ( head == Symbol._apply_ ) { // (apply <closure> [args])				AbEntity closureExpr = exp.cdr().car();				AbEntity expandsTo = Nil.instance();				AbOrderedCollection revParameters = (AbOrderedCollection) eval(exp.cdr().cdr(),env); // not in tail position				while ( !revParameters.isEmpty() ) {					expandsTo = Pair.cons(revParameters.first(),expandsTo);					revParameters = revParameters.butFirst();				}				exp = Pair.cons(closureExpr,expandsTo);				isTail = true;			}			else if ( head == Symbol._call_ep_ ) {				EscapeException ce = new EscapeException();				DilutedEscape de = new DilutedEscape(ce);				escapeSet.put(de,de);				try {					exp = eval(Pair.list(exp.cdr().car(),de),env);					escapeSet.remove(de);				}				catch (EscapeException ex) {					escapeSet.remove(de);					if ( ex.equals(ce) ) // our exception!						exp = ex.getReturn();					else throw ex;				}			}			else if ( head == Symbol._valid_exitQ_ ) {				AbEntity exit = exp.cdr().car();				if ( !exit.isanEscape() )					throw new Exception( exit.pp() + "is not an exit in "+exp.pp() );				exp = Bool.valueOf(escapeSet.get(exit) != null);			}			else {							//				// APPLYING A FUNCTION				//				// get the function to apply				//								AbEntity lambda = exp.car();				AbEntity originalExp = exp;								if ( !lambda.isaFunction() )					lambda = eval(lambda, env); // not in tail position--but do we HAVE to? Let's try saving time...								if ( lambda.isanEscape() )					((DilutedEscape) lambda).invoke(eval(exp.cdr().car(),env));									exp = exp.cdr();								codestorm.util.CodableVector parVect = new codestorm.util.CodableVector(16,8); // initial capacity, capacity increment								if ( lambda.isSpecial() )					while ( exp.isaPair() ) {						parVect.addElement(exp.car());						exp = exp.cdr();					}				else while ( exp.isaPair() ) {					parVect.addElement(eval(exp.car(),env));					exp = exp.cdr();				}								if ( lambda.isaPrimitive() ) {					try {						exp = ((SuPrimitive) lambda).invoke(parVect,env);					}					catch (IndexOutOfBoundsException ioobe) {						throw new Exception("Wrong arity for primitive "+lambda.pp()+" in "+originalExp.pp());					}					catch (ClassCastException cce) {						throw new Exception("Wrong parameter type ("+cce.getMessage()+") for primitive in "+originalExp.pp());					}					isTail = lambda.isSpecial(); // if it is special, evaluate the results of the invocation!				}				else {					if ( lambda.isSpecial() ) {						exp = eval(							((Closure) lambda).getExpression(),							((Closure) lambda).invocationEnv(parVect));						// the macro call is not in tail position, but the subsequent evaluation is.						// the environment remains unchanged-- the result is evaluated in *this* environment					}					else {						exp = ((Closure) lambda).getExpression();						env = ((Closure) lambda).invocationEnv(parVect);						// a function call is in tail position and the environment does change					}					isTail = true;				}			}		}			if ( debugFlag ) {			expOutStr = exp.pp();			if ( traceFlag) {				System.err.println(expInStr);				System.err.println("  --> "+expOutStr);			}			else {				System.err.print(expInStr.substring(0,0));				System.err.print(expOutStr.substring(0,0));			}		}			} while ( isTail || exp.isExpandable() );		return exp;}public AbEntity meaning (AbEntity exp) throws Exception {	return meaning(exp,global(),Nil.instance());}public AbEntity meaning (AbEntity exp, AbEnvironment env) throws Exception {	return meaning(exp,env,Nil.instance());}protected AbEntity meaning (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	AbEntity expIn = exp;	try {		String expInStr = "";		String expOutStr = "";				if ( debugFlag) {			expInStr = exp.pp();		}		if ( exp.isaSymbol() )			exp = meaningSymbol(exp,env,context);		else if ( exp.isaThunk() )			exp = meaningThunk(exp,env,context);		else if ( exp.isanAtom() )			;		else if ( exp.isaPair() ) {					AbEntity head = exp.car();						if ( head == Symbol._quote_ )				exp = meaningQuote(exp,env,context);			else if ( head == Symbol._if_ )				exp = meaningIf(exp,env,context);			else if ( head == Symbol._define_ )				exp = meaningDefine(exp,env,context);			else if ( head == Symbol._setBang_ || head == Symbol._setStarBang_ ) 				exp = meaningSetBang(exp,env,context);			else if ( head == Symbol._lambda_ )				exp = meaningLambda(exp,env,context);			else if ( head == Symbol._macro_ )				exp = meaningMacro(exp,env,context);			else if ( head == Symbol._call_ep_ )				exp = meaningCallEP(exp,env,context);			else if ( head == Symbol._valid_exitQ_ )				exp = meaningValidExitQ(exp,env,context);			else if ( head == Symbol._call_with_values_ )				exp = meaningCallWithValues(exp,env,context);			else if ( head == Symbol._begin_ )				exp = meaningBegin(exp,env,context);			else if ( head == Symbol._apply_ )				exp = meaningApply(exp,env,context);			else if ( head == Symbol._tail_apply_ )				exp = exp;			else exp = meaningApplication(exp,env,context);					}				if ( debugFlag ) {			expOutStr = exp.pp();			if ( traceFlag) {				System.err.println(expInStr);				System.err.println("  --> "+expOutStr);			}			else {				System.err.print(expInStr.substring(0,0));				System.err.print(expOutStr.substring(0,0));			}		}				return exp;		}	catch (Exception e) {		System.err.println("Unable to get meaning of "+expIn+" to "+exp+" in "+env+" because "+e.getMessage());		throw e;	}}private AbEntity meaningSymbol (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	AbEnvironment foundEnv = env.locate((Symbol) exp);	if ( foundEnv == null ) { // could be a forward reference to a global() symbol		System.err.println("WARNING: "+exp.pp() + " seems to be undefined in "+(debugFlag ? env.pp() : "the current environment"));		return exp; // leave unaltered	}	else return meaning(RefThunk.valueOf(((Symbol) exp),env),env,context);}private AbEntity meaningThunk (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	boolean isaConstant = false;		if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	try {		isaConstant = ((AbThunk) exp).isConst(env);	}	catch (Exception e) {		System.err.println("Unable to determine that "+exp.pp()+" is a constant in "+(debugFlag ? env.pp() : "the current environment")+" because "+e.getMessage());	}	if ( isaConstant )		try {			return ((AbThunk) exp).lookup(env);		}		catch (Exception ee) {			System.err.println("Unable to look "+exp.pp()+" up in "+(debugFlag ? env.pp() : "the current environment")+" because "+ee.getMessage());			return exp;		}	else return exp;}private AbEntity meaningQuote (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	return Parser.makeConst(exp.cdr().car());}private AbEntity meaningIf (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception { // a little const propagation	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	AbEntity result;		AbEntity choice = meaning(exp.cdr().car(),env,context);	AbEntity truth = meaning(exp.cdr().cdr().car(),env,context);	AbEntity falsehood = exp.cdr().cdr().cdr().isaPair() ?		meaning(exp.cdr().cdr().cdr().car(),env,context) :		Uninitialized.instance(); // unspecified values in r4rs		if ( choice.isaPair() ) {		AbEntity choiceOp = choice.car();		if ( choiceOp.eqv(Not.instance()) 			|| ( choiceOp.isaThunk() && ((AbThunk) choiceOp).isConst(env) && ((AbThunk) choiceOp).lookup(env).eqv(Not.instance()) )) {			AbEntity temp = truth;			truth = falsehood;			falsehood = temp;			choice = choice.cdr().car();		}	}		AbEntity uncertainty = Pair.list(Symbol._if_,choice,truth,falsehood);		if ( choice.isaThunk() ) {		if ( ((AbThunk) choice).isConst(env) )			result = ((AbThunk) choice).lookup(env);		else result = choice;	}	else result = choice;		if ( result.eq(Bool.valueOf(true)) )		return truth;	else if ( result.eq(Bool.valueOf(false)) )		return falsehood;	else return uncertainty;	}private AbEntity meaningDefine (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	AbEntity target = exp.cdr().car();	if ( target.isaSymbol() ) { // (define expInStr ...)		AbEntity definition = meaning(exp.cdr().cdr().car(),env,context);		if ( definition.isSpecial() )			env.define(target,definition);		else env.define(target,Uninitialized.instance());		if ( exp.cdr().cdr().isaPair() )			return Pair.list(				Symbol._define_,				target,				definition);		else return exp;	}	else if ( target.isaPair() ) { // (define (expInStr x) ...)		AbEntity sym = target.car();		if ( !sym.isaSymbol() )			throw new Exception( "Attempt to define "+sym.pp() + " as a function");		else if ( exp.cdr().cdr().isaPair() ) {// supplied with a symbol			env.define(sym,Uninitialized.instance());			return Pair.list(				Symbol._define_,				sym,				meaningLambda(					Pair.list(						Symbol._lambda_,						target.cdr(),						exp.cdr().cdr().car()),					env,					context));		}		else throw new Exception( exp.pp() + " is illegal because defined functions must include a body");	}	else if ( target.isaThunk() ) { // already a thunk--do not optimize		AbEntity definition = meaning(exp.cdr().cdr().car(),env,context);		return Pair.list(			Symbol._define_,			target,			definition);	}	else throw new Exception( target.pp() + " must be a symbol or list in define");}private AbEntity meaningSetBang (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	AbEntity sym = exp.cdr().car();	// if ( sym.isaSymbol() )		sym = meaning(sym,env,context); 	// set! is never tail-recursive, so we can use a trick to handle (set! expInStr (lambda (...) ...))	AbEntity myContext = Symbol.gensym();		if ( sym.isaThunk() )		((AbThunk) sym).bind(env,myContext);	// else throw new Exception("Unexpected "+sym.pp()+" where a thunk was expected in "+exp.pp());		AbEntity setting = meaning(exp.cdr().cdr().car(),env,myContext);	if ( sym.isaThunk() ) { // already a thunk--no optimization really possible		if ( setting.isSpecial() )			((AbThunk) sym).bind(env,setting);		return Pair.list(exp.car(), sym, setting); // value	}	else if ( sym.isaSymbol() ) {		if ( setting.isSpecial() )			env.bind((Symbol) sym, setting);		return Pair.list(exp.car(), RefThunk.valueOf(((Symbol) sym),env), setting); // value	}	else if ( sym.isaPair() ) { // generalized variable: (set! (foo bar*) blitz)		AbEntity accessor = meaning(sym.car(),env,context);		AbEntity inversionArgumentList = Pair.list(meaning(exp.cdr().cdr().car(),env,context)); // (blitz)		AbEntity accessorArguments = sym.cdr(); // (bar*)		AbEntity reversedAccessorArguments = Nil.instance();		while ( !accessorArguments.isNIL() ) {			reversedAccessorArguments = Pair.cons( accessorArguments.car(), reversedAccessorArguments );			accessorArguments = accessorArguments.cdr();		}		while ( !reversedAccessorArguments.isNIL() ) {			inversionArgumentList = Pair.cons( meaning(reversedAccessorArguments.car(),env,context), inversionArgumentList );			reversedAccessorArguments = reversedAccessorArguments.cdr();		}		if ( accessor.isanAccessor() ) // optimize constant inversions like primitives!!!			return Pair.cons(				((AbFunction) accessor).getInversion(),				inversionArgumentList);		else return Pair.cons(			Pair.list(				GetInversion.instance(),				accessor),			inversionArgumentList);	}	else throw new Exception("Don't know what to do with "+sym.pp() + " in set!");}private AbEntity meaningLambda (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	if ( exp.cdr().car().isaClosure() )		return exp;	else {		Closure lambda = new Closure(exp.cdr().car(),Nil.instance(),env);		AbEnvironment lambdaEnv = lambda.invocationEnv(); // temporary, to get an environment		lambda.setSuperClosure(false); // be optimistic!!!		AbEntity lambdaExpr = meaning(Pair.cons(Symbol._begin_, exp.cdr().cdr()),lambdaEnv,context); // lambdaEnv may be stretched from lambda hoisting		Vect parameterVect = (Vect) (new Vect()).replaceAll((AbOrderedCollection) exp.cdr().car()); // easy to addLast!		for ( int i = parameterVect.size(); i < lambdaEnv.getSize(); ++i )			parameterVect.addLastBang(Symbol.gensym());		codestorm.util.CodableVector parentVector = lambdaEnv.getParentVector();		for ( int i = 0; i < parentVector.size(); ++i ) {			Closure c = ((AbEnvironment) parentVector.elementAt(i)).getClosure();			if ( c != null ) {				c.setSuperClosure(true); // all these environments contain a lambda which could be invoked!			}		}		Closure retClosure = new Closure(				Nil.instance().addAllFirst(parameterVect),				lambdaExpr,				lambdaEnv,				false);		retClosure.setSuperClosure(lambda.getSuperClosure());		return Pair.list(Symbol._lambda_,retClosure);	}}private AbEntity meaningMacro (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	Closure lambda = new Closure(exp.cdr().car(),Nil.instance(),env);	lambda.setExpression(meaning(exp.cdr().cdr().car(),lambda.invocationEnv(),context));	lambda.setSpecial(true);	return Parser.makeConst(lambda);}private AbEntity meaningCallEP (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	return Pair.list(Symbol._call_ep_, meaning(exp.cdr().car(), env,context));}private AbEntity meaningCallWithValues (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	AbEntity closureExpr = exp.cdr().cdr().car();	AbEntity thunkExpr = exp.cdr().car();	AbEntity ret;	if ( closureExpr.isaPair() && closureExpr.car().eq(Symbol._lambda_) ) { // optimize explicit thunk case		AbEntity lambdaParameters = closureExpr.cdr().car(); // (x y)		if ( lambdaParameters.isaPair()  ) {			codestorm.util.CodableVector pSyms = new codestorm.util.CodableVector();			codestorm.util.CodableVector pVals = new codestorm.util.CodableVector();			while ( lambdaParameters.isaPair() ) { // reverse list				AbEntity sym = lambdaParameters.car();				if ( !sym.isaSymbol() )					throw new Exception(sym.pp()+" must be a symbol");				pSyms.addElement(sym);				pVals.addElement(Uninitialized.instance());				lambdaParameters = lambdaParameters.cdr();			}			int envCurrentSize = env.getSize();			env.stretch(pSyms,pVals);			AbEntity bodyExpr = meaning(closureExpr.cdr().cdr().car(),env,context);			env.shrink();			ret = Pair.list(				Symbol._begin_,				Pair.list(					Symbol._setStarBang_,					new LocalThunk((Symbol) pSyms.elementAt(0),envCurrentSize),					Pair.list(thunkExpr)),				bodyExpr);		}		else ret = Pair.list(			Symbol._begin_,			Pair.list(thunkExpr),			closureExpr.cdr().cdr().car());	}	else ret = Pair.list(		Symbol._apply_,		closureExpr,		thunkExpr);	return meaning(ret,env,context);		}private AbEntity meaningValidExitQ (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	if ( exp.cdr().isNIL() || !exp.cdr().cdr().isNIL() )		throw new Exception("Incorrect arity for valid-exit?");	AbEntity exit = exp.cdr().car();	return Pair.list(Symbol._valid_exitQ_,meaning(exit,env,context));}private AbEntity meaningBegin (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	int numExprs = 0;	AbEntity revList = Nil.instance();	AbEntity expList = exp.cdr();	if ( expList.isNIL() )		throw new Exception("Incorrect arity for begin");	while ( expList.isaPair() ) {		AbEntity eachExpr = meaning(expList.car(),env,context);		if ( eachExpr.isaPair() // skip any (set! ... %%UNINITIALIZED%%)			&& eachExpr.car().eq(Symbol._setBang_)			&& !eachExpr.cdr().cdr().car().isInitialized() )			expList = expList.cdr(); // move to next		else if ( eachExpr.isaPair() && eachExpr.car().eq(Symbol._begin_) ) // flatten (begin ... (begin ...) ...)			expList = ((AbOrderedCollection) expList.cdr()).addAllFirst((AbOrderedCollection) eachExpr.cdr());		else {			revList = Pair.cons(eachExpr,revList); // must be in correct order for side effects, esp. letrec			expList = expList.cdr(); // move to next		}	}	expList = Nil.instance();	while ( revList.isaPair() ) {		expList = Pair.cons(revList.car(),expList);		revList = revList.cdr();		++numExprs;	}	// singleton elimination	if ( numExprs > 1)		return Pair.cons(Symbol._begin_,expList);	else return expList.car();}private AbEntity meaningApply (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}	AbEntity closureExpr = exp.cdr().car();	AbEntity argExpr = exp.cdr().cdr().isaPair() ? exp.cdr().cdr().car() : Nil.instance();	if ( closureExpr.isaPair() && closureExpr.car().eq(Symbol._lambda_) ) { // often a side-effect of call-with-values expansion		codestorm.util.CodableVector pSyms, pVals;		pSyms = new codestorm.util.CodableVector();		pVals = new codestorm.util.CodableVector();		AbEntity lambdaParameters = closureExpr.cdr().car(); // (x y)		AbEntity lambdaBodyExpr = closureExpr.cdr().cdr().car(); // (+ x y)		while ( lambdaParameters.isaPair() ) { // reverse list			pVals.addElement(Uninitialized.instance());			AbEntity p = lambdaParameters.car();			lambdaParameters = lambdaParameters.cdr();			if ( p.isaSymbol() )				pSyms.addElement(p);			else throw new Exception(p.pp()+" must be a symbol to be a parameter for "+closureExpr.pp());		}		if ( pSyms.isEmpty() ) {			if ( !argExpr.isNIL() )				throw new Exception("Unexpected arguments for closure "+closureExpr.pp()+" in "+exp.pp());			else return meaning(lambdaBodyExpr,env,context);		}		else {			if ( argExpr.isNIL() )				throw new Exception("No arguments for closure "+closureExpr.pp()+" in "+exp.pp());			else {				int envCurrentSize = env.getSize();				env.stretch(pSyms,pVals);				AbEntity beginExpr = meaning(lambdaBodyExpr,env,context);				env.shrink();				return meaning(					Pair.list(						Symbol._begin_,						Pair.list(							Symbol._setStarBang_,							new LocalThunk((Symbol) pSyms.elementAt(0),envCurrentSize),							meaning(argExpr,env,context)),						beginExpr),					env,					context);			}		}	}	else if ( argExpr.isNIL() )		return Pair.list(			Symbol._apply_,			meaning(closureExpr,env,context));	else return Pair.list(			Symbol._apply_,			meaning(closureExpr,env,context),			meaning(argExpr,env,context));}private AbEntity meaningApplication (AbEntity exp, AbEnvironment env, AbEntity context) throws Exception {	String aaaDebugStr = "";	if ( debugFlag ) {		aaaDebugStr = exp.pp();		System.err.print(aaaDebugStr.substring(0,0));	}		boolean tailRecursiveFlag = false;	boolean iterativeFlag = false;	AbEntity actualLambda, lambdaExpr;	codestorm.util.CodableVector pSyms, pVals;	pSyms = new codestorm.util.CodableVector();	pVals = new codestorm.util.CodableVector();	int parVectSize, parIndex = 0;	AbEntity valueExpressionList = exp.cdr();		if ( exp.car().isaPair() && exp.car().car().eq(Symbol._lambda_) ) {		// 'captive' lambda		// we know with precision exactly what the arguments are and where it will be called,		// unlike a lambda bound to a variable.		// we don't want to get the meaning of the lambda because it messes up our		// tail-iterative optimization :-)				// e.g. ((lambda (x y) (+ x y)) 1 2)		// valueExpressionList is (1 2)		lambdaExpr = exp.car(); // (lambda (x y) (+ x y))		AbEntity lambdaParameters = lambdaExpr.cdr().car(); // (x y)		AbEntity lambdaBodyExpr = lambdaExpr.cdr().cdr().car(); // (+ x y)		while ( valueExpressionList.isaPair() ) { // reverse list			pVals.addElement(meaning(valueExpressionList.car(),env,context)); // gets meaning in current environment			if ( lambdaParameters.isaPair() ) {				AbEntity p = lambdaParameters.car();				lambdaParameters = lambdaParameters.cdr();				if ( p.isaSymbol() )					pSyms.addElement(p);				else throw new Exception(p.pp()+" must be a symbol to be a parameter for "+lambdaExpr.pp());			}			else throw new Exception("Too many values applied to captive lambda in "+exp.pp());			valueExpressionList = valueExpressionList.cdr();		}		int envCurrentSize = env.getSize();		env.stretch(pSyms,pVals);		AbEntity beginExpr = Pair.list(meaning(lambdaBodyExpr,env,context));		env.shrink();		AbEntity pValExpr = exp.cdr();		for ( int i = 0; i < pSyms.size(); ++i ) {			if ( pValExpr.isaPair() ) {				beginExpr = Pair.cons(					Pair.list(						Symbol._setBang_,						new LocalThunk((Symbol) pSyms.elementAt(i),i+envCurrentSize),						pValExpr.car()),					beginExpr);				pValExpr = pValExpr.cdr();			}		}		// we convert to (begin ...) !!!		Closure c = env.getClosure();		AbEntity retExpr;		if ( c != null )			retExpr = meaning(Pair.cons(Symbol._begin_,beginExpr),env,context);		else retExpr = meaning(Pair.cons(Symbol._begin_,beginExpr),env,context);		// shrink may not be correct--do we have a problem with closures referring to a variable inside a let?		// env.shrink();		return retExpr;	}	else {		lambdaExpr = meaning(exp.car(),env,context);		// will convert ((lambda (...) ...) ...) to ((lambda ¥) ...) !!!		if ( lambdaExpr.isaThunk() ) {			if ( ((AbThunk) lambdaExpr).isConst(env) ) {				actualLambda = ((AbThunk) lambdaExpr).lookup(env); // get the actual lambda				if ( !actualLambda.isaFunction() )					throw new Exception( actualLambda.pp() + " must be a function to be applied in " + exp.pp() );			}			else actualLambda = Nil.instance();						tailRecursiveFlag = ((AbThunk) lambdaExpr).lookup(env).eq(context);		}		else if ( lambdaExpr.isaFunction() )			actualLambda = lambdaExpr;		else actualLambda = Nil.instance();				if ( !actualLambda.isNIL() && actualLambda.isSpecial() ) { // NIL is never special, but why leave a subtle bug?			codestorm.util.CodableVector parList = new codestorm.util.CodableVector();			AbEntity remList = exp.cdr();			while ( remList.isaPair() ) {				parList.addElement(remList.car());				remList = remList.cdr();			}			AbEntity finalExp;			if ( actualLambda.isaPrimitive() ) {				try {					finalExp = meaning(((SuPrimitive) actualLambda).invoke(parList,env),env,context);				}				catch (IndexOutOfBoundsException ioobe) {					throw new Exception("Wrong arity for primitive in "+exp.pp());				}				catch (ClassCastException cce) {					throw new Exception("Wrong parameter type ("+cce.getMessage()+") for primitive in "+exp.pp());				}			}			else {				AbEntity intermediateExp = this.eval(						((Closure) actualLambda).getExpression(),						((Closure) actualLambda).invocationEnv(parList));				finalExp = meaning(intermediateExp,env,context); // evaluate it and process the result IN THIS ENVIRONMENT			}			return finalExp;		}		else if ( lambdaExpr.isaPair() && lambdaExpr.car().eq(Symbol._lambda_) ) {					Closure lambdaClosure = (Closure) lambdaExpr.cdr().car();			Vect parameterSymbolVect = lambdaClosure.getParameterVect();			parVectSize = ((Vect) parameterSymbolVect).size();			while ( valueExpressionList.isaPair() ) { // reverse list				pVals.addElement(meaning(valueExpressionList.car(),env,context));				if ( parIndex < parVectSize ) {					AbEntity p = parameterSymbolVect.elementAt(parIndex++);					if ( p.isaSymbol() )						pSyms.addElement(p);					else throw new Exception(p.pp()+" must be a symbol to be a parameter for "+lambdaExpr.pp());				}				else throw new Exception("Too many values applied to lambda in "+exp.pp());				valueExpressionList = valueExpressionList.cdr();			}			if ( exp.car().isaPair() && exp.car().car().eq(Symbol._lambda_) ) {				// 'captive' lambda				// we know with precision exactly what the arguments are and where it will be called,				// unlike a lambda bound to a variable.				// We have to re-interpret, because the original lambdaExpr will no longer be valid:				// the original 'meaning' will interpret thunks in their own environment, not the hoisted				// environment.				lambdaExpr = exp.car(); // restore 'raw' code				AbEntity lambdaParameters = lambdaExpr.cdr().car();				AbEntity lambdaBodyExpr = lambdaExpr.cdr().cdr().car();				int envCurrentSize = env.getSize();				env.stretch(pSyms,pVals);				AbEntity beginExpr = Pair.list(meaning(lambdaBodyExpr,env,context));				env.shrink(); // hides new names				AbEntity pValExpr = exp.cdr();				for ( int i = 0; i < pSyms.size(); ++i ) {					if ( pValExpr.isaPair() ) {						beginExpr = Pair.cons(							Pair.list(								Symbol._setBang_,								new LocalThunk((Symbol) pSyms.elementAt(i),i+envCurrentSize),								pValExpr.car()),							beginExpr);						pValExpr = pValExpr.cdr();					}				}				// we convert to (begin ...) !!!				AbEntity retExpr = meaning(Pair.cons(Symbol._begin_,beginExpr),env,context);				// env.shrink();				return retExpr;			}			else {				AbEnvironment subEnv = new Environment(env);				subEnv.extend(pSyms,pVals); // bind values for optimization purposes				lambdaExpr = Pair.list(					Symbol._lambda_,					lambdaExpr.cdr().car(),					meaning(lambdaExpr.cdr().cdr().car(),subEnv,context));				return Pair.cons(lambdaExpr,exp.cdr());			}		}		else { // standard			AbEntity tempValueExpressionList = Nil.instance();			while ( valueExpressionList.isaPair() ) { // reverse list				tempValueExpressionList = Pair.cons(valueExpressionList.car(),tempValueExpressionList);				valueExpressionList = valueExpressionList.cdr();			}			valueExpressionList = Nil.instance();			while ( tempValueExpressionList.isaPair() ) { // restore list order & process; order irrelevant, unlike (begin...)				valueExpressionList = Pair.cons(meaning(tempValueExpressionList.car(),env,context),valueExpressionList); // get the meaning while we go				tempValueExpressionList = tempValueExpressionList.cdr();			}			if ( tailRecursiveFlag )				return Pair.cons( Symbol._tail_apply_, Pair.cons(lambdaExpr,valueExpressionList) );			else return Pair.cons(lambdaExpr,valueExpressionList);		}	}}public static AbEntity values () {	return Nil.instance();}public static AbEntity values (AbEntity a) {	return Pair.list(a);}public static AbEntity values (AbEntity a,AbEntity b) {	return Pair.list(a,b);}public static AbEntity values (AbEntity a,AbEntity b,AbEntity c) {	return Pair.list(a,b,c);}public static AbEntity values (AbEntity a,AbEntity b,AbEntity c,AbEntity d) {	return Pair.list(a,b,c,d);}public static AbEntity values (AbEntity a,AbEntity b,AbEntity c,AbEntity d,AbEntity e) {	return Pair.list(a,b,c,d,e);}public static AbEntity values (AbEntity a,AbEntity b,AbEntity c,AbEntity d,AbEntity e,AbEntity f) {	return Pair.list(a,b,c,d,e,f);}}