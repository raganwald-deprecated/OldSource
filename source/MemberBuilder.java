/** * MemberBuilder.java * * Copyright (c) 1996, 1997 Codestorm Inc. All rights reserved. ***/package COM.codestorm.builders;/** * A MemberBuilder knows whether and how to build a specific member. * * We use MemberBuilders so that MemberEnvelopes don't need to know about all of the * possible members. MemberBuilders are nils! ***/import COM.codestorm.mendel.*;import COM.codestorm.thunks.*;import java.util.*;import java.io.*;import COM.objectspace.jgl.*;import COM.codestorm.publisher.*;class MemberBuilder {	// all singletons!	private static Hashtable builderCache;	private static FrameBuilder frameBuilder;	private static StringBuilder stringBuilder;	private static OrdCollectionBuilder ordCollectionBuilder;	private static HTMLBuilder htmlBuilder;	private static MethodBuilder methodBuilder;	static {		builderCache = new Hashtable(); // must be first declaration, or BOOM!		new AliasBuilder();		frameBuilder = new FrameBuilder();		stringBuilder = new StringBuilder();		ordCollectionBuilder = new OrdCollectionBuilder();		htmlBuilder = new HTMLBuilder();		methodBuilder = new MethodBuilder();	}	protected static final String stateStart			= "__start__";	protected static final String stateProperties		= "__properties__";	protected static final String stateVerifyEnd		= "__verifyEnd__";	protected static final String stateNotEndEval		= "__notEndEval__";	protected static final String stateAboutToEnd		= "__aboutToEnd__";	protected static final String stateHotMetal		= "__hotMetal__";	protected static final String stateVerifyEval		= "__verifyEval__";	protected static final String stateIsEval			= "__isEval__";	protected static final String stateStop			= "__stop__";	protected static final String statePossibleMember	= "__possibleMember__";	protected static final String stateVerifyMemberTag	= "__verifyMember__";	protected static final String stateMembers			= "__members__";	protected static final String defaultWord			= "__default__";	synchronized private static void registerMemberBuilder (String s, MemberBuilder mb) {		builderCache.put(filter(s),mb.getClass());	}	public static AbstractMember buildMember ()  throws IOException, MendelException {		return frameBuilder.newMember();	}	public static final String filter (String s) {		return s.toUpperCase();	}	public static AbstractMember buildMember (MemberTokenizer t, AbstractMemberContainer container) throws IOException, MendelException {		String word = MemberBuilder.filter(t.currentWord());				synchronized (builderCache) {			if ( !MemberBuilder.builderCache.containsKey(word) ) throw new NotAMemberException(word);		}		try {			return ((MemberBuilder) ((Class) builderCache.get(word)).newInstance()).newMemberFromTokenizer(t,container);		}		catch (IllegalAccessException iae) {			throw new MendelException("Illegal Access: "+iae.getMessage());		}		catch (InstantiationException ie) {			throw new MendelException("Instantiation: "+ie.getMessage());		}	}/*	public static AbstractMember buildMember (String s) throws MendelException {		return stringBuilder.newMember(s);	}*/	public static AbstractMember buildMember (Vector v, AbstractMemberContainer container) throws MendelException {		AbstractMember myVect = buildMember(v);		myVect.setStaticScope(container);		return myVect;	}	public static AbstractMember buildMember (Vector v) throws MendelException {		return ordCollectionBuilder.newMember(v.elements());	}/*	public static AbstractMember buildMember (Hashtable h) throws MendelException {		return frameBuilder.newMember(h);	}*/	public static AbstractMember buildMember (Enumeration e) throws MendelException {		return ordCollectionBuilder.newMember(e);	}		public static AbstractMember buildMember (File f) throws MendelException {		return buildMember(f,Root.instance());	}		public static AbstractMember buildMember (File f, AbstractMemberContainer scope) throws MendelException {		String path = f.getPath();		AbstractMember newMember;				if ( !f.exists() )			throw new MendelException( path + " does not exist" );		if ( path.endsWith(".hpp") )			try {				FileInputStream plusPlusFileStream = new FileInputStream(f.getAbsolutePath());				try {					AbstractMemberContainer directory;					newMember = buildFromInputStream(plusPlusFileStream,scope);					newMember.putProperty(AbstractMember.keyInPath,path);//					newMember.putVariableStrategy(OSFileVariable.instance(f));				}				finally {					plusPlusFileStream.close();				}			}			catch (IOException ioe) {				throw new MendelException(ioe.getMessage());			}		else if ( path.endsWith(".text") || path.endsWith(".txt") ) {			byte[] b = new byte[0];				try {				RandomAccessFile myFile = new RandomAccessFile(path, "r");				myFile.seek(0);				b = new byte[(int) myFile.length()];				myFile.read(b);				myFile.close();			}			catch (IOException ioe) {}			finally {				newMember = stringBuilder.newMember(new String(b,0x00));//				newMember.putVariableStrategy(OSFileVariable.instance(f));			}		}		else if ( path.endsWith(".tab") ) { // tab delimited file			newMember = ordCollectionBuilder.newMember(f,false);		}		else if ( path.endsWith(".tbn") ) { // tab delimited file, first line elements are field names			newMember = ordCollectionBuilder.newMember(f,true);		}		else if ( path.endsWith(".html") || path.endsWith(".htm") ) {			byte[] b = new byte[0];				try {				RandomAccessFile myFile = new RandomAccessFile(path, "r");				myFile.seek(0);				b = new byte[(int) myFile.length()];				myFile.read(b);				myFile.close();			}			catch (IOException ioe) {}			finally {				newMember = HTMLMember.valueOf(new String(b,0x00), scope);			}		}		else if ( f.isDirectory() ) {			newMember = new Folder(f);//			String propertyPath = f.getAbsolutePath()//					+ f.pathSeparator//					+ Defaults.getProperty(Defaults.kIndexName)//					+ Defaults.getProperty(Defaults.kPropertiesSuffix);//			if ( (new File(propertyPath)).exists() ) {//				try {//					FileInputStream propertiesFile = new FileInputStream(propertyPath);//					Properties folderProperties = new Properties();//					folderProperties.load(propertiesFile);//					newMember.properties.setDefaults(folderProperties);//				}//				catch (Exception e) {}//			}		}		else newMember = new BlobMember(f);		AbstractMemberContainer container;		if ( f.isDirectory() )			if ( f.getAbsolutePath().equals(Defaults.getRootPath()) )				container = (AbstractMemberContainer) ManufacturedMember.Empty;			else container = newMember.getStaticScope(MissingMember.Empty);		else {			try {				container = new Frame();				String parentPath = f.getParent();				if ( parentPath != null ) {					File parentFile = new File(parentPath);					if ( parentFile.exists() && parentFile.isDirectory() )						container.setStaticScope(new ManufacturedMember(new File(parentFile.getPath())));					else container = Root.instance();				}			}			catch (IOException ioe) {				throw new MendelException(ioe.getMessage());			}		}		newMember.setStaticScope(container);		newMember.putProperty(AbstractMember.keyInPath,f.getAbsolutePath());		newMember.putProperty(AbstractMember.keyName,f.getName());//		OSFileVariable myVariableStrategy = OSFileVariable.instance(f);//		newMember.putVariableStrategy(myVariableStrategy);		String publishString = newMember.getProperty(Defaults.getProperty(Defaults.kPublishFlag),"YES");		if ( publishString.length() > 0 && ((publishString.charAt(0) == 'y') || (publishString.charAt(0) == 'Y')) )			if ( newMember.getPublishStrategy() == null ) {				MirrorPublisher newPublisher = new MirrorPublisher(newMember);//				myVariableStrategy.addObserver(newPublisher);				newMember.putPublishStrategy(newPublisher);			}		return newMember;	}	public MemberBuilder () {}	protected AbstractMember newMember;	protected MemberBuilder (String s) {		MemberBuilder.registerMemberBuilder(s, this);	}	protected static AbstractMember buildFromInputStream (FileInputStream in, AbstractMemberContainer scope) throws IOException, MendelException {		byte[] b = new byte[0];		StringBuffer buf = new StringBuffer();		try {			int avail = in.available();			while ( avail > 0 ) {				b = new byte[avail];				in.read(b);				buf.append(new String(b,0x00));				avail = in.available();			}		}		catch (IOException ioe) {}		finally {			in.close();						// first, remove all methods						Sequence methodList = new SList();			String stringRep = MethodBuilder.processMethods(buf.toString(),methodList);			int nextEscape = stringRep.indexOf(MethodBuilder.methodEscape);			Enumeration e = methodList.elements();			while ( nextEscape >= 0 ) {				stringRep = stringRep.substring(0,nextEscape) + MethodBuilder.methodTag + stringRep.substring(nextEscape+MethodBuilder.methodEscape.length());				nextEscape = stringRep.indexOf(MethodBuilder.methodEscape);			}						// then, it is safe to remove all HTML members						Sequence htmlList = new SList();			stringRep = ScriptThunk.processHTML(stringRep,htmlList);			nextEscape = stringRep.indexOf(ScriptThunk.htmlEscape);			e = htmlList.elements();			while ( nextEscape >= 0 ) {				stringRep = stringRep.substring(0,nextEscape) + Defaults.openHTML + Defaults.closeTag + stringRep.substring(nextEscape+ScriptThunk.htmlEscape.length());				nextEscape = stringRep.indexOf(ScriptThunk.htmlEscape);			}						// now make the tokenizer and initialize the enumerations			MemberTokenizer t = new MemberTokenizer(new StringBufferInputStream(stringRep));			t.htmlElements = htmlList.elements();			t.methodElements = methodList.elements();						t.useTagSyntax();			while ( t.nextToken() != MemberTokenizer.openTagToken )				/* do nothing */;			t.nextToken();			return buildMember(t, scope);		}	}	protected Hashtable getLookupTable () {		return null;	}	protected AbstractMember newMemberFromTokenizer (MemberTokenizer t, AbstractMemberContainer container) throws IOException, MendelException {		this.newMember = this.newMember();		this.newMember.setStaticScope(container);		this.parseFromTokenizer(t);		this.postParse(container);		return this.newMember;	}	synchronized protected void postParse (AbstractMemberContainer container) throws MendelException, IOException { // common case of the EXTENDS property		String extendsPath = this.newMember.getProperty(AbstractMember.keyExtends,"");		if ( !extendsPath.equals("") ) {			this.newMember.setParent(new ThunkEnvelope(extendsPath, (AbstractMemberContainer) (container != null ? container : this.newMember) ));		}	}	synchronized protected void parseFromTokenizer (MemberTokenizer t) throws IOException, MendelException {		Hashtable stateLookupTable = getLookupTable();		String state = MemberBuilder.stateStart;		String newstate;		boolean pushedComments = false;				while ( !state.equals(MemberBuilder.stateStop) ) {					Hashtable stateTable = (Hashtable) stateLookupTable.get(state);			if ( stateTable == null ) 				throw new MendelException(this.getClass()+" No state table built for state " + state);			else newstate = (String) stateTable.get(t.currentWord());			if (newstate == null)				newstate = (String) stateTable.get(MemberBuilder.defaultWord);			if (newstate == null)				throw new MendelException(this.getClass()+" No entry or default for "+t.currentWord()+" in state "+state);						state = newstate;					if (state.equals(MemberBuilder.stateStart)) {				t.useTagSyntax();			} else if (state.equals(MemberBuilder.stateProperties)) {				t.parseProperties(this.newMember);				if ( this.isAtomicTag() )					state = MemberBuilder.stateStop;				else {					String commentString = this.newMember.getProperty(AbstractMember.keyComments,"");					if ( !commentString.equals("") ) {						t.pushComment(commentString.toUpperCase().startsWith("T"));						pushedComments = true;					}				}			} else if ( this.pluggableStateTest(state,t) ) {				// do nothing--pluggableStateTest returns true if it has handled			}						if ( !state.equals(MemberBuilder.stateStop) )				t.nextToken();		}				if ( pushedComments )			t.popComment();	}	protected boolean isAtomicTag () {		return false;	}	protected boolean pluggableStateTest (String state, MemberTokenizer t) throws IOException, MendelException {		return false;	}	protected AbstractMember newMember () throws MendelException {		return null;	}}